{"version":3,"sources":["System/Promises/LazyPromise.js","System/Promises/LazyPromise.ts"],"names":["define","require","exports","Promise_1","defer_1","ArgumentNullException_1","extends_1","Object","defineProperty","value","__extends","VOID0","LazyPromise","_super","_resolver","_this","call","this","ArgumentNullException","_resolvedCalled","prototype","_onDispose","_onThen","r","resolveUsing","thenSynchronous","onFulfilled","onRejected","doneNow","delayFromNow","milliseconds","throwIfDisposed","isSettled","pass","timedOut","timeout","defer","resolve","reject","v","e","dispose","delayAfterResolve","finalize","detector","isPending","TSDNPromise"],"mappings":";;;;AAIAA,QAAQ,UAAW,UAAW,YAAa,qBAAsB,sCAAuC,iBAAkB,SAAUC,EAASC,EAASC,EAAWC,EAASC,EAAyBC,GAC/L,YACAC,QAAOC,eAAeN,EAAS,cAAgBO,OAAO,GCM1D,IAAMC,GAAYJ,EAAAA,WAEZK,EAAY,OAKlBC,EAAA,SAAAC,GAGC,QAAAD,GAAoBE,GAApB,GAAAC,GAECF,EAAAG,KAAAC,OAAOA,IACP,IAHmBF,EAAAD,UAAAA,GAGfA,EAAW,KAAM,IAAIT,GAAAa,sBAAsB,WDJrC,OCKVH,GAAKI,iBAAkB,EDLNJ,ECsLnB,MAxLoCL,GAAAE,EAAAC,GAUzBD,EAAAQ,UAAAC,WAAV,WAECR,EAAAO,UAAMC,WAAUL,KAAAC,MAChBA,KAAKH,UAAYH,GAGVC,EAAAQ,UAAAE,QAAR,WAEC,GAAMC,GAAIN,KAAKH,SACZS,KAEFN,KAAKH,UAAYH,EACjBM,KAAKE,iBAAkB,EACvBF,KAAKO,aAAaD,KAIpBX,EAAAQ,UAAAK,gBAAA,SACCC,EACAC,GAGA,MADAV,MAAKK,UACET,EAAAO,UAAMK,gBAAeT,KAAAC,KAACS,EAAaC,IAI3Cf,EAAAQ,UAAAQ,QAAA,SACCF,EACAC,GAEAV,KAAKK,UACLT,EAAAO,UAAMQ,QAAOZ,KAAAC,KAACS,EAAaC,IAU5Bf,EAAAQ,UAAAS,aAAA,SAAaC,GAAb,GAAAf,GAAAE,IAKC,IALY,SAAAa,IAAAA,EAAA,GAEZb,KAAKc,mBAGDd,KAAKH,WAAaG,KAAKe,UAC1B,MAAOnB,GAAAO,UAAMS,aAAYb,KAAAC,KAACa,EAO3B,IAAIG,GACAC,GAAmB,EAGnBC,EAAU/B,EAAAgC,MAAM,WAElBF,GAAW,EAERD,GACFA,KAEFH,EAED,OAAO,IAAIlB,GACV,SAACyB,EAASC,GAGTL,EAAO,WAENlB,EAAKa,QACJ,SAAAW,GAAI,MAAAF,GAAQE,IACZ,SAAAC,GAAI,MAAAF,GAAOE,KAEZL,EAAQM,UACRN,EAAUxB,EACVsB,EAAOtB,GAILuB,GACFD,OAWJrB,EAAAQ,UAAAsB,kBAAA,SAAkBZ,GAAlB,GAAAf,GAAAE,IAKC,IALiB,SAAAa,IAAAA,EAAA,GAEjBb,KAAKc,mBAGDd,KAAKH,WAAaG,KAAKe,UAC1B,MAAOnB,GAAAO,UAAMsB,kBAAiB1B,KAAAC,KAACa,EAOhC,IAAIG,GAIAE,EAEAQ,EAAW,WAEXR,IAEFA,EAAQM,UACRN,EAAUxB,GAGRsB,GACFA,IAEDU,EAAWhC,GAIPiC,EAAW,WAEXD,IACFR,EAAU/B,EAAAgC,MAAMO,EAAUb,IAW7B,OALCjB,GAAAO,UAAMQ,QAAOZ,KAAAC,KAAC2B,EAAUA,GAExBA,EAAgB,KAGV,GAAIhC,GACV,SAACyB,EAASC,GAGNvB,EAAK8B,WAEP9B,EAAKa,QACJ,SAAAW,GAAI,MAAAnC,GAAAgC,MAAM,WAAI,MAAAC,GAAQE,IAAIT,IAC1B,SAAAU,GAAI,MAAApC,GAAAgC,MAAM,WAAI,MAAAE,GAAOE,IAAIV,KAE1Ba,MAKAV,EAAO,WAENlB,EAAKa,QACJ,SAAAW,GAAI,MAAAF,GAAQE,IACZ,SAAAC,GAAI,MAAAF,GAAOE,MAKTG,GACHV,QAMNrB,GAxLoCT,EAAA2C,YAAvB5C,GAAAU,YAAAA,EA0LbV,EAAAA,WAAeU","file":"LazyPromise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\ndefine([\"require\", \"exports\", \"./Promise\", \"../Threading/defer\", \"../Exceptions/ArgumentNullException\", \"../../extends\"], function (require, exports, Promise_1, defer_1, ArgumentNullException_1, extends_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    /**\n     * A promise that waits for the first then to trigger the resolver.\n     */\n    var LazyPromise = (function (_super) {\n        __extends(LazyPromise, _super);\n        function LazyPromise(_resolver) {\n            var _this = _super.call(this) || this;\n            _this._resolver = _resolver;\n            if (!_resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            _this._resolvedCalled = true;\n            return _this;\n        }\n        LazyPromise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolver = VOID0;\n        };\n        LazyPromise.prototype._onThen = function () {\n            var r = this._resolver;\n            if (r) {\n                this._resolver = VOID0;\n                this._resolvedCalled = false;\n                this.resolveUsing(r);\n            }\n        };\n        LazyPromise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.doneNow = function (onFulfilled, onRejected) {\n            this._onThen();\n            _super.prototype.doneNow.call(this, onFulfilled, onRejected);\n        };\n        // NOTE: For a LazyPromise we need to be careful not to trigger the resolve for delay.\n        /**\n         * Will yield for a number of milliseconds from the time called before continuing.\n         * @param milliseconds\n         * @returns A promise that yields to the current execution and executes after a minimum delay.\n         */\n        LazyPromise.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            // If this is already guaranteed to resolve, the go ahead and pass to the super.\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayFromNow.call(this, milliseconds);\n            /*\n             * If not triggered yet, then we create a special promise\n             * that only requests the resolution from the parent promise\n             * if a 'then' is called to ensure the lazy pattern.\n             */\n            var pass;\n            var timedOut = false;\n            // Setup the timer.\n            var timeout = defer_1.defer(function () {\n                timedOut = true;\n                // If the promise was requested already go ahead and pass the request on to the parent.\n                if (pass)\n                    pass();\n            }, milliseconds);\n            return new LazyPromise(function (resolve, reject) {\n                // A lazy promise only enters here if something called for a resolution.\n                pass = function () {\n                    _this.doneNow(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    timeout.dispose();\n                    timeout = VOID0;\n                    pass = VOID0;\n                };\n                // If the timeout completed already go ahead and pass the request on to the parent.\n                if (timedOut)\n                    pass();\n                // Otherwise wait for the timeout to do it.\n            });\n        };\n        /**\n         * Will yield for a number of milliseconds from after this promise resolves.\n         * If the promise is already resolved, the delay will start from now.\n         * @param milliseconds\n         * @returns A promise that yields to the current execution and executes after a delay.\n         */\n        LazyPromise.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            // If this is already guaranteed to resolve, the go ahead and pass to the super.\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayAfterResolve.call(this, milliseconds);\n            /*\n             * If not triggered yet, then we create a special promise\n             * that only requests the resolution from the parent promise\n             * if a 'then' is called to ensure the lazy pattern.\n             */\n            var pass;\n            // Setup the timer.\n            var timeout;\n            var finalize = function () {\n                if (timeout) {\n                    timeout.dispose();\n                    timeout = VOID0;\n                }\n                // If the promise was requested already go ahead and pass the request on to the parent.\n                if (pass)\n                    pass();\n                finalize = VOID0;\n            };\n            {\n                var detector = function () {\n                    if (finalize)\n                        timeout = defer_1.defer(finalize, milliseconds);\n                };\n                // Calling super.doneNow does not trigger resolution.\n                // This simply waits for resolution to happen.\n                // Is effectively the timer by when resolution has occurred.\n                _super.prototype.doneNow.call(this, detector, detector);\n                //noinspection JSUnusedAssignment\n                detector = null;\n            }\n            return new LazyPromise(function (resolve, reject) {\n                // Because of the lazy nature of this promise, this could enter here at any time.\n                if (_this.isPending) {\n                    _this.doneNow(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n                    finalize();\n                }\n                else {\n                    // We don't know when this resolved and could have happened anytime after calling this delay method.\n                    pass = function () {\n                        _this.doneNow(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    };\n                    // Already finalized (aka resolved after a timeout)? Go now!\n                    if (!finalize)\n                        pass();\n                }\n            });\n        };\n        return LazyPromise;\n    }(Promise_1.TSDNPromise));\n    exports.LazyPromise = LazyPromise;\n    exports.default = LazyPromise;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {TSDNPromise, PromiseBase} from \"./Promise\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ICancellable} from \"../Threading/ICancellable\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any = void 0;\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends TSDNPromise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:TSDNPromise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tconst r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r);\r\n\t\t}\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TResult>,\r\n\t\tonRejected?:TSDNPromise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenSynchronous(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tdoneNow(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):void\r\n\t{\r\n\t\tthis._onThen();\r\n\t\tsuper.doneNow(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t// NOTE: For a LazyPromise we need to be careful not to trigger the resolve for delay.\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a minimum delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayFromNow(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tlet pass:Closure;\r\n\t\tlet timedOut:boolean = false;\r\n\r\n\t\t// Setup the timer.\r\n\t\tlet timeout = defer(() =>\r\n\t\t\t{\r\n\t\t\t\ttimedOut = true;\r\n\t\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(pass)\r\n\t\t\t\t\tpass();\r\n\t\t\t},\r\n\t\t\tmilliseconds);\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// A lazy promise only enters here if something called for a resolution.\r\n\t\t\t\tpass = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.doneNow(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\ttimeout.dispose();\r\n\t\t\t\t\ttimeout = VOID0;\r\n\t\t\t\t\tpass = VOID0;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If the timeout completed already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(timedOut)\r\n\t\t\t\t\tpass();\r\n\t\t\t\t// Otherwise wait for the timeout to do it.\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayAfterResolve(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tlet pass:Closure;\r\n\r\n\r\n\t\t// Setup the timer.\r\n\t\tlet timeout:ICancellable;\r\n\r\n\t\tlet finalize = () =>\r\n\t\t{\r\n\t\t\tif(timeout)\r\n\t\t\t{\r\n\t\t\t\ttimeout.dispose();\r\n\t\t\t\ttimeout = VOID0;\r\n\t\t\t}\r\n\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\tif(pass)\r\n\t\t\t\tpass();\r\n\r\n\t\t\tfinalize = VOID0;\r\n\t\t};\r\n\r\n\t\t{\r\n\t\t\tlet detector = ()=>\r\n\t\t\t{\r\n\t\t\t\tif(finalize) // We may already be wrapped up so never mind!\r\n\t\t\t\t\ttimeout = defer(finalize, milliseconds);\r\n\t\t\t};\r\n\r\n\t\t\t// Calling super.doneNow does not trigger resolution.\r\n\t\t\t// This simply waits for resolution to happen.\r\n\t\t\t// Is effectively the timer by when resolution has occurred.\r\n\t\t\tsuper.doneNow(detector, detector);\r\n\t\t\t//noinspection JSUnusedAssignment\r\n\t\t\tdetector = <any>null;\r\n\t\t}\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// Because of the lazy nature of this promise, this could enter here at any time.\r\n\t\t\t\tif(this.isPending)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.doneNow(\r\n\t\t\t\t\t\tv=> defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\t\te=> defer(()=>reject(e), milliseconds)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfinalize();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// We don't know when this resolved and could have happened anytime after calling this delay method.\r\n\t\t\t\t\tpass = ()=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.doneNow(\r\n\t\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Already finalized (aka resolved after a timeout)? Go now!\r\n\t\t\t\t\tif(!finalize)\r\n\t\t\t\t\t\tpass();\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t}\r\n}\r\n\r\nexport default LazyPromise;"]}